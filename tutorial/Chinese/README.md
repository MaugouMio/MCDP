# 基礎教學
-	**基本概念** <br>
	MCDP 所有操作均需在命令提示字元 (cmd) 中執行，執行時會以 cmd 當前路徑為基準建立或尋找檔案，關於 cmd 中路徑設定相關內容請詳見[維基](https://zh.wikipedia.org/wiki/Cd_(%E5%91%BD%E4%BB%A4))內容。若成功安裝 MCDP 後，在 cmd 中輸入 "mcdp" 應該會出現可用指令的提示。

-	**建立專案** <br>
	輸入`mcdp create <專案名稱>`在當前目錄建立一個對應名稱的專案資料夾。專案名稱可以是一個路徑，程式會在指定路徑建立專案資料夾，並以路徑中最後的目錄替專案命名，專案名稱與位置可以在日後隨時修改。
	專案資料夾中存放著`__main__.dpl`檔案與`build`資料夾，其中`__main__.dpl`即是我們的腳本文件，不可更改其位置與名稱。而未來建置好的資料包則會存放在`build`資料夾中。

-	**編輯腳本** <br>
	你可以使用任何文字編輯軟體編輯 dpl 腳本，若你是 notepad++ 的使用者，可以下載 [highlight xml for notepad++](https://www.mediafire.com/file/93hgdfqin7kseq3/dpl.xml/file) 並套用 highlight。

	**Highlight 套用教學：** 打開 Notepad++ ➔ 程式語言 ➔ 定義程式語言 ➔ 匯入... ➔ 選擇下載的`dpl.xml`檔案 ➔ 完成

-	**建置資料包** <br>
	輸入`mcdp make <專案資料夾位置>`嘗試將專案建置為資料包。建置完成的資料包會存放在專案資料夾中的`build`資料夾內。

-	**安裝函式庫** <br>
	輸入`mcdp install <函式庫名稱>`從網路上下載並安裝對應的函式庫 (尚未實現)。

	將寫好的專案資料夾或單純的腳本文件放置在安裝的`mcdp`資料夾中的`lib`資料夾內，其他腳本文件就能根據檔案名稱引用該專案中的內容，注意檔案名稱不能有空格。另外也可以將它們放置在你的專案資料夾內，與`__main__.dpl`位於相同目錄底下的檔案都可以被該專案引用。

	輸入`mcdp uninstall <函式庫名稱>`將指定名稱的函式庫從`lib`資料夾中移除。

---

# dpl 格式介紹
詳細格式範例可以參見 [samp](https://github.com/MaugouMio/MCDP/tree/master/samp) 的內容。<br>
內容採逐行讀取模式，除安插的 python 程式碼外沒有縮排限制。<br>
-	**空行：** 沒有限制，讀取過程會直接忽略空行。
-	**註解：** 該行內容的開頭 (不含縮排) 為`#`符號時代表該行為註解，將視為空行處理。
-	**字串：** 由雙引號`""`包裝的文字視為字串，部分需要輸入文字的內容可以使用字串。
-	**資料包敘述：** 以`description = <敘述字串>`格式編寫，不可換行，敘述字串的內容可以是字串類型。
-	**宣告檔案：** <br>
	行的開頭可以用`namespace`/`folder`/`func`分別宣告`namespace 資料夾`/`普通資料夾`/`function檔案`。其中`namespace 資料夾`的名稱不能重複，除非先前宣告的`namespace 資料夾`是*虛擬檔案*。但在同一個`namespace`底下的檔案若有重複的名稱，則後宣告的檔案會覆蓋先宣告的檔案。

	例如用`namespace test()`宣告一個名叫`test`的`namespace 資料夾`。要注意建立檔案母子關係時，最上層的檔案必須是`namespace`類別，`namespace`類別中也不可以定義其它`namespace`類別的內容。小括號內可以傳入參數名稱，以逗號或空格分隔，可以使用字串。需要注意的是有設定參數的檔案必須設定為*虛擬檔案* (`as virtual`)，後面會再詳細說明。

	宣告完一個檔案後可以在同一行後面加上其它參數，例如`from`與`as virtual`。
	其中`from`後面必須接續其它已定義的檔案，例如`folder test2() from test()`會將上述宣告的`test`這個`namespace`中定義的內容複製到`test2`這個資料夾。若`test`有設定參數，這邊也需要在`test`後面的小括號傳入對應數量的參數。假設`test`這個`namespace`中有另外宣告`test3`這個資料夾，若是想要複製`test3`的內容到`test2`中，則可以使用`folder test2() from test().test3()`，以點`.`來串接子檔案。

	要注意`from`的來源檔案類型必須與宣告的檔案類型相容，其中`func`不可以與`namespace`或`folder`相容，但`namespace`與`folder`類型則可相容。

	而`as virtual`必須宣告在該行的最後面，代表這個檔案是*虛擬檔案*。虛擬檔案可以被其它宣告的檔案使用`from`來引用，但是不會在建置資料包的時候被建置出來。

-	**區塊：** 完成檔案的宣告後，會從接下來的內容中讀取區塊。<br>
	區塊是由大括號`{}`包裝的範圍，其中`{`與`}`兩個符號都必須個別存在獨立的一行中，不可包含其它內容，否則會導致判讀錯誤。另外可以在宣告檔案的那行的末尾加上分號`;`代表一個空的區塊，例如`func test();`。分號在資料夾類型的檔案宣告中與空的括號無異，但在`function`檔案的宣告中，如果使用空括號則會由空的內容取代先前已經存在的內容。

	資料夾類型檔案的區塊中可以宣告其它資料夾檔案或`function`檔案，而`function`檔案的區塊中則是每一行都視為一條 Minecraft 指令，並且忽略縮排。

	若是宣告的檔案有包含參數，在接下來的區塊中可以使用`ARG(參數名稱)`代表當參數傳入時要被對應替代的內容。接下來在讀取這個區塊的時候，會先將所有參數替代成對應的內容再進行讀取。<br>
	另外在`function`檔案的指令內容中可以使用系統參數`ARG(_PATH)`。在建置資料包時會被替換為：使用 function 指令呼叫該 function 時，其所在資料夾的路徑。<br>
	例如`sample:test`中的`sample:`或`sample:test/test2`中的`sample:test/`。

-	**標籤：** 宣告`tick`與`load`兩種標籤，使指定 function 連閃或在載入時執行。<br>
	分別透過`tag tick`以及`tag load`來宣告兩種標籤，宣告完必須接續一個區塊，不可使用分號作為空區塊。區塊內每一行的內容會被視為一個 function 名稱，與 Minecraft 中呼叫 function 時輸入的名稱相同，並且依序添加到標籤當中。需要注意的是，若對應的`namespace`被設定為*虛擬檔案*，則與該`namespace`相關的標籤都不會被套用。

-	**引入：** <br>
	分為兩種引入方式，兩種均能在該行最後加上`as virtual`參數，將引入的`namespace`檔案設定為*虛擬檔案*。

	第一種格式為`import <函式庫名稱1>[, <函式庫名稱2> [, ...]]`<br>
	例如`import test`或`import test1, test2`。函式庫名稱不能有空格，也不接受字串形式的輸入，要引入的函式庫之間以逗號或空格隔開。程式會從專案資料夾以及系統安裝的函式庫中尋找對應名稱的腳本文件或專案內容，並將其中宣告的`namespace`檔案引入到你的專案中。

	第二種格式為`from <函式庫名稱> import <namespace1>[, <namespace2>[, ...]]`<br>
	例如`from test import test1`或`from test import test1, test2`。注意只能輸入一個函式庫，程式會從該函式庫找到對應名稱的`namespace`引入到你的專案中。

-	**安插 Python 程式碼：** <br>
	你可以安插部分 Python 3 的程式碼在腳本中，用以產生腳本內容。

	要安插 Python 程式碼，你必須先在獨立的一行中輸入\`\`\`作為開端，並同樣以獨立的一行\`\`\`作為結尾。其中程式碼內容的縮排必須與第一行的\`\`\`對齊，一個 tab 視為 4 個空格處理。將你要產生的腳本內容透過`print()`的方式打印出來，完整執行整段程式之後會將打印出來的內容視為一般腳本內容進行讀取。

	要注意在解析 Python 程式碼的時候有區塊層級問題，程式只會解析當前區塊中的 Python 程式碼，內層區塊中的 Python 程式碼會在讀取該區塊的時候才被解析。
